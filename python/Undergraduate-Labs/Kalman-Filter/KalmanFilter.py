import numpy as np
from matplotlib import pyplot as plt
from scipy import linalg as la


class KalmanFilter(object):
	def __init__(self,F,Q,H,R,u):
		"""
		Initialize the dynamical system models.

		Parameters
		----------
		F : ndarray of shape (n,n)
			The state transition model.
		Q : ndarray of shape (n,n)
			The covariance matrix for the state noise.
		H : ndarray of shape (m,n)
			The observation model.
		R : ndarray of shape (m,m)
			The covariance matric for observation noise.
		u : ndarray of shape (n,)
			The control vector.
		"""
		self.F = F
		self.Q = Q
		self.H = H
		self.R = R
		self.u = u

	def evolve(self,x0,N):
		"""
		Compute the first N states and observations generated by the Kalman system.

		Parameters
		----------
		x0 : ndarray of shape (n,)
			The initial state.
		N : integer
			The number of time steps to evolve.

		Returns
		-------
		states : ndarray of shape (n,N)
			The i-th column gives the i-th state.
		obs : ndarray of shape (m,N)
			The i-th column gives the i-th observation.
		"""
		m,n = self.H.shape
		states = np.zeros((n,N))
		obs = np.zeros((m,N))
		x = x0.copy()
		states[:,0] = x
		v1 = np.random.multivariate_normal(np.zeros(m),self.R)
		obs[:,0] = self.H.dot(x) + v1

		for i in xrange(1,N):
			v1 = np.random.multivariate_normal(np.zeros(m),self.R)
			v2 = np.random.multivariate_normal(np.zeros(n),self.Q)
			xnew = self.F.dot(x) + self.u + v2
			states[:,i] = xnew
			z = self.H.dot(x) + v1
			obs[:,i] = z
			x = xnew
			
		return states, obs
		
	def estimate(self,x0,P0,z,return_norms=False):
		"""
		Compute the state estimates using the kalman filter.

		Parameters
		----------
		x0 : ndarray of shape (n,)
		The initial state estimate.
		P0 : ndarray of shape (n,n)
			The initial error covariance matrix.
		z : ndarray of shape(m,N)
		Sequence of N observations (each column is an observation).

		Returns
		-------
		out : ndarray of shape (n,N)
		Sequence of state estimates (each column is an estimate).
		norms: list of floats of length N
		Gives the norm of the error matrix for each estimate.
		"""
		m,n = self.H.shape
		x = x0.copy()
		p = P0.copy()
		out = np.zeros((P0.shape[1],z.shape[1]))
		norms = [la.norm(p)]
		
		for i in xrange(z.shape[1]):
			xnew = self.F.dot(x) + self.u
			out[:,i] = xnew
			pnew = self.F.dot(p).dot(self.F.T) + self.Q
			yk = z[:,i] - self.H.dot(xnew)
			sk = self.H.dot(pnew).dot(self.H.T) + self.R
			kk = pnew.dot(self.H.T).dot(la.inv(sk))
			x = xnew + kk.dot(yk)
			p = (np.eye(n) - kk.dot(self.H)).dot(pnew)
			norms.append(la.norm(p))

		if return_norms:
			return out, norms
		else:
			return out
			


	def predict(self,x0,k):
		"""
		Predict the next k states in the absence of observations.

		Parameters
		----------
		x : ndarray of shape (n,)
		The current state estimate.
		k : integer
		The number of states to predict.

		Returns
		-------
		out : ndarray of shape (n,k)
		The next k predicted states.
		"""
		out = np.zeros((x0.size,k))
		x = x0.copy()

		for i in xrange(k):
			xnew = self.F.dot(x) + self.u
			out[:,i] = xnew
			x = xnew

		return out

	def rewind(self,x0,k):
		"""
		Predict the states from time 0 through k-1 in the absence of observations.

		Parameters
			----------
		x : ndarray of shape (n,)
			The state estimate at time k.
		k : integer
			The current time step.

		Returns
		-------
		out : ndarray of shape (n,k)
			The predicted states from time 0 up through k-1 (in that order).
		"""
		out = np.zeros((x0.size,k))
		x = x0.copy()

		for i in xrange(k):
			xnew = la.inv(self.F).dot(x - self.u)
			out[:,i] = xnew
			x = xnew

		return out
